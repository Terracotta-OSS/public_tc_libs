/*
 * Copyright (c) 2012-2018 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.terracottatech.sovereign.time;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.util.Objects;
import java.util.function.Supplier;

/**
 * Supports generation of {@link TimeReference} instances.
 * <p>
 * An implementation of {@code TimeReferenceGenerator} may be stateless or stateful.
 * Although an implementation may be stateless, all {@code TimeReferenceGenerator} implementations
 * <b>must</b> be serializable (or externalizable) to permit persistence of the
 * {@code TimeReferenceGenerator} instance with a dataset's configuration.  An implementation of
 * {@code TimeReferenceGenerator} altering internal state during the {@code TimeReference} instance
 * generation process must either provide manage its own persistence or participate in the
 * persistence scheme of a storage provider implementing the TC Store interfaces.
 * <p>
 * Although the default implementations of {@code TimeReferenceGenerator.put(ByteBuffer, TimeReference}
 * and {@code TimeReferenceGenerator.get(ByteBuffer} may be used when {@code TimeReference}
 * implements {@code Serializable} or {@code Externalizable}, significant performance improvement
 * is possible by providing implementations specific to the {@code TimeReference} implementation.
 *
 * @param <Z> the type of the {@link TimeReference} handled by this class
 *
 * @author Clifford W. Johnson
 */
@SuppressWarnings("serial")
public interface TimeReferenceGenerator<Z extends TimeReference<?>>
    extends Supplier<Z>, Serializable {

  /**
   * Returns the {@code Class} representing the {@link TimeReference} type generated by this
   * {@code TimeReferenceGenerator}.
   *
   * @return the {@code Class} instance of the {@code TimeReference} produced by this generator
   */
  Class<Z> type();

  /**
   * Returns a {@link TimeReference} instance representing the current instant in time.
   *
   * @return a {@code TimeReference} instance representing the current instant in time
   */
  @Override
  Z get();

  /**
   * Returns the maximum length, in bytes, of the serialized value of a {@code TimeReference}
   * ({@code <Z>}) instance built using this {@code TimeReferenceGenerator}.  This is the number of
   * bytes that should be present in the {@code ByteBuffer} passed to the
   * {@link #put(ByteBuffer, TimeReference)} method to prevent a {@code BufferOverflowException}.
   *
   * @return the maximum byte length of {@code <Z>}
   */
  int maxSerializedLength();

  /**
   * Appends the serialized representation of the {@code TimeReference} instance provided to the
   * {@code ByteBuffer} provided.
   * <p>
   * The default implementation of this method and the {@link #get(ByteBuffer)} method should be
   * overridden with an implementation optimized for serializing the specific {@code TimeReference}
   * implementation.
   *
   * @param buffer the non-{@code null} {@code ByteBuffer} instance to which {@code this} is appended
   * @param timeReference the {@code TimeReference} instance, possibly {@code null}, to append to {@code buffer}
   *
   * @throws IOException if an error occurs while serializing {@code timeReference}
   * @throws NullPointerException if {@code buffer} is {@code null}
   * @throws java.nio.BufferOverflowException if {@code buffer} is too small to hold {@code timeReference}
   * @throws java.nio.ReadOnlyBufferException if {@code buffer} is not writable
   */
  @SuppressFBWarnings("DMI_NONSERIALIZABLE_OBJECT_WRITTEN")
  default void put(ByteBuffer buffer, TimeReference<?> timeReference) throws IOException {
    Objects.requireNonNull(buffer, "buffer");
    try (final ByteArrayOutputStream byteStream = new ByteArrayOutputStream()) {
      try (final ObjectOutputStream objectStream = new ObjectOutputStream(byteStream)) {
        objectStream.writeObject(timeReference);
      }
      buffer.put(byteStream.toByteArray());
    }
  }

  /**
   * Instantiates a {@code TimeReference} from the serialized representation in the {@code ByteBuffer}
   * provided.
   * <p>
   * The default implementation of this method presumes Java serialization/externalization was used
   * to serialize the {@code TimeReference} instance.  This method should be overridden to provide
   * an implementation consistent with {@link #put(ByteBuffer, TimeReference)}.
   *
   * @param buffer the non-{@code null} {@code ByteBuffer} holding the serialized {@code TimeReference};
   *               the buffer will be positioned to the first byte of the serialized {@code TimeReference}
   * @return a new {@code TimeReference} constructed from the serialized data in {@code buffer}; may be
   *      {@code null} if indicated by the serialized data
   *
   * @throws IOException if an error is raised while deserializing the {@code TimeReference} from {@code buffer}
   * @throws ClassNotFoundException if the object deserialized from {@code buffer} is not of a available class
   * @throws ClassCastException if the deserialized object is not a {@link TimeReference} of the type
   *        returned by {@link #type()}
   * @throws NullPointerException if {@code buffer} is {@code null}
   */
  default Z get(ByteBuffer buffer) throws IOException, ClassNotFoundException {
    Objects.requireNonNull(buffer, "buffer");

    final class ByteBufferInputStream extends InputStream {
      private final ByteBuffer buffer;

      private ByteBufferInputStream(final ByteBuffer buffer) {
        this.buffer = buffer;
      }

      @Override
      public int read() throws IOException {
        return Byte.toUnsignedInt(buffer.get());
      }
    }

    try (final InputStream byteStream = new ByteBufferInputStream(buffer);
         final ObjectInputStream objectStream = new ObjectInputStream(byteStream)) {
      return this.type().cast(objectStream.readObject());
    }
  }
}
