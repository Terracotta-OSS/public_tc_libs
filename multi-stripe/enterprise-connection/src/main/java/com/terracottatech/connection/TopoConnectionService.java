/*
 * Copyright (c) 2012-2018 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.terracottatech.connection;

import com.tc.classloader.OverrideService;
import com.tc.util.UUID;
import com.terracotta.connection.EndpointConnector;
import com.terracotta.connection.api.DetailedConnectionException;
import com.terracotta.connection.api.TerracottaConnectionService;
import com.terracottatech.connection.disconnect.DisconnectDetectingEndpointConnector;
import com.terracottatech.connection.disconnect.RelayDisconnectListener;
import com.terracottatech.tools.client.TopologyEntity;
import com.terracottatech.tools.client.TopologyEntityProvider;
import com.terracottatech.tools.config.Cluster;
import com.terracottatech.tools.config.ClusterConfiguration;
import com.terracottatech.tools.config.Stripe;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.terracotta.connection.Connection;
import org.terracotta.connection.ConnectionException;
import org.terracotta.connection.ConnectionPropertyNames;
import org.terracotta.connection.entity.EntityRef;
import org.terracotta.exception.EntityException;
import org.terracotta.lease.connection.BasicLeasedConnection;
import org.terracotta.lease.connection.LeasedConnection;
import org.terracotta.lease.connection.LeasedConnectionService;
import org.terracotta.lease.connection.TimeBudget;

/**
 * A connection service that reads a stripe definition file generated by
 * cluster-tool and connects to all the stripes in the cluster.
 */
@OverrideService("org.terracotta.lease.connection.LeasedConnectionServiceImpl")
public class TopoConnectionService implements LeasedConnectionService {
  private static Logger LOGGER = LoggerFactory.getLogger(TopoConnectionService.class);
  private static final TerracottaConnectionService CLUSTER_CONNECT = new TerracottaConnectionService() {
    /**
    * these overrides should be considered temporary.  Since we are selecting the connection service
    * by hand (no service loader involved) these methods should always return true. This allows
    * the INFORMATIONAL product type to be selected by StandardClientBuilder. All this should be
    * cleaned up in core so that the INFORMATIONAL ProductID is selected by the appropriate ClientBuilder
    * rather than overloading CONNECTION_TYPE
    */
    @Override
    public boolean handlesConnectionType(String connectionType) {
      return true;
    }

    @Override
    public boolean handlesURI(URI uri) {
      return true;
    }
  };
  private static final String PROBE_CONNECTION_NAME = "TopologyProbeConnection";
  private static final String DEFAULT_CONNECTION_TIMEOUT = "20000";

  private final StripeConnectionFactory stripeConnectionFactory;

  public TopoConnectionService() {
    this(new TerracottaStripeConnectionFactory());
  }

  public TopoConnectionService(StripeConnectionFactory stripeConnectionFactory) {
    this.stripeConnectionFactory = stripeConnectionFactory;
  }

  @Override
  public LeasedConnection connect(URI uri, Properties properties) throws ConnectionException {
    try {
      Connection connection = CLUSTER_CONNECT.connect(changeScheme(uri), modifyProperties(properties));
      return createLeasedConnection(properties, connection);
    } catch (DetailedConnectionException e) {
      throw ExceptionUtils.getConnectionException(e, properties);
    }
  }

  @Override
  public LeasedConnection connect(Iterable<InetSocketAddress> servers, Properties properties) throws ConnectionException {
    try {
      Connection connection = CLUSTER_CONNECT.connect(servers, modifyProperties(properties));
      return createLeasedConnection(properties, connection);
    } catch (DetailedConnectionException e) {
      throw ExceptionUtils.getConnectionException(e, properties);
    }
  }

  private LeasedConnection createLeasedConnection(Properties properties, Connection base) throws ConnectionException {
    TimeBudget timeBudget = createTimeBudget(properties);
    List<Connection> connections = new ArrayList<>();
    boolean cleanup = false;

    try {
      EntityRef<TopologyEntity, Void, Void> ref = base.getEntityRef(TopologyEntity.class, TopologyEntityProvider.ENTITY_VERSION, TopologyEntityProvider.ENTITY_NAME);
      TopologyEntity te = ref.fetchEntity(null);
      ClusterConfiguration cc = te.getClusterConfiguration();
      Cluster configs = cc.getCluster();

      RelayDisconnectListener relayDisconnectListener = new RelayDisconnectListener();

      Properties realProperties = new Properties();
      realProperties.putAll(properties);
      //  Set a connection uuid to be shared across stripes
      realProperties.setProperty(ConnectionPropertyNames.CONNECTION_UUID, UUID.getUUID().toString());
      realProperties.putIfAbsent(ConnectionPropertyNames.CONNECTION_TIMEOUT, DEFAULT_CONNECTION_TIMEOUT);

      int stripeIndex = 0;
      for (Stripe config : configs.getStripes()) {
        checkRemainingTime(timeBudget);
        List<InetSocketAddress> servers = config.serverInetAddresses();
        Connection conn = connectToStripe(stripeIndex++, servers, realProperties, relayDisconnectListener);

        if (conn != null) {
          BasicLeasedConnection leasedConnection = BasicLeasedConnection.create(conn, timeBudget);
          connections.add(leasedConnection);
        } else {
          throw new ConnectionException(new IOException("stripe unavailable " + servers));
        }
      }

      BasicMultiConnection multiConnection = new BasicMultiConnection(connections);
      relayDisconnectListener.setDisconnectListener(multiConnection);

      return multiConnection;
    } catch (ConnectionException e) {
      cleanup = true;
      throw e;
    } catch (EntityException ee) {
      cleanup = true;
      throw new ConnectionException(ee);
    } finally {
      if (cleanup) {
        cleanup(connections);
      }
      try {
        base.close();
      } catch (IOException ioe) {
        throw new ConnectionException(ioe);
      }
    }
  }

  private Properties modifyProperties(Properties properties) {
    Properties baseProperties = new Properties();
    baseProperties.putAll(properties); // We must do this via putAll(properties) not new Properties(properties) - read the constructor javadoc
    baseProperties.setProperty(ConnectionPropertyNames.CONNECTION_NAME, PROBE_CONNECTION_NAME);
    baseProperties.setProperty(ConnectionPropertyNames.CONNECTION_TYPE, "INFORMATIONAL");
    baseProperties.remove(ConnectionPropertyNames.CONNECTION_UUID);
    return baseProperties;
  }

  private void checkRemainingTime(TimeBudget timeBudget) throws ConnectionException {
    long remainingTime = timeBudget.remaining(TimeUnit.MILLISECONDS);

    if (remainingTime <= 0) {
      throw new ConnectionException(new IOException("Timed out creating connection"));
    }
  }

  private TimeBudget createTimeBudget(Properties properties) {
    String timeoutString = properties.getProperty(ConnectionPropertyNames.CONNECTION_TIMEOUT, DEFAULT_CONNECTION_TIMEOUT);
    long timeout = Long.parseLong(timeoutString);
    return new TimeBudget(timeout, TimeUnit.MILLISECONDS);
  }

  private void cleanup(List<Connection> connections) {
    for (Connection named : connections) {
      try {
        named.close();
      } catch (IOException ignore) {
        LOGGER.warn("error closing", ignore);
      }
    }
  }

  private URI changeScheme(URI original) {
    try {
      return new URI(original.toString().replace("cluster://", "terracotta://"));
    } catch (URISyntaxException e) {
      LOGGER.error("Updating URI scheme failed in " + original, e);
      return original;
    }
  }

  private Connection connectToStripe(int stripeIndex, Iterable<InetSocketAddress> servers, Properties props, RelayDisconnectListener disconnectListener) throws ConnectionException {
    EndpointConnector endpointConnector = new DisconnectDetectingEndpointConnector(disconnectListener);
    return stripeConnectionFactory.createStripeConnection(stripeIndex, endpointConnector, servers, props);
  }

  @Override
  public boolean handlesURI(URI uri) {
    return handlesConnectionType(uri.getScheme());
  }

  @Override
  public boolean handlesConnectionType(String connectionType) {
    return connectionType.equals("terracotta") || connectionType.equals("cluster");
  }
}
